//scalapackage coop.rchain.rholang.proofofstake

// No. | Dependency | Computation method | Result
// ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------
// 1.  |            | given              | sk = 68b39a809d6a009d76593c26d4b897acfd34d40b2fa9639df4605a1317d3448e
// 2.  |            | given              | timestamp = 1553702123276
// 3.  |            | lastNonce          | nonce = 9223372036854775807
// 4.  | 1,         | ed25519            | pk = da19138c71db4010e791f40cbf73fb1e5dda989a8f3f5bca83f324b6529c5869
// 5.  | 4, 2,      | genIds             | uname = Unforgeable(0xb56db0764203ab770365c99e5e6abe90f4fa96768b4333e1858cbe847e8b3331)
// 6.  | 3, 5,      | registry           | value = (9223372036854775807, bundle+ {   Unforgeable(0xb56db0764203ab770365c99e5e6abe90f4fa96768b4333e1858cbe847e8b3331) })
// 7.  | 6,         | protobuf           | toSign = 2a3eaa013b0a0d2a0b10feffffffffffffffff010a2a5a280a243a220a20b56db0764203ab770365c99e5e6abe90f4fa96768b4333e1858cbe847e8b33311001
// 8.  | 7, 1,      | ed25519            | sig = ed32eef76c52261643566de4a9305d3a63385598c66d800ace0002141243ba212eae6171a7d2899f60957c3cb497fa5eca84106b02e708e084867fc902003e03
// 9.  | 4,         | registry           | uri = rho:id:w6koqnba5yr3f9hmtckihj4mj6q6wtre48w5j3n6nd314zwogyfmuf
// ----+------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------

new MakePoS,
    rs(`rho:registry:insertSigned:ed25519`),
    uriOut in {

    contract MakePoS (@minimumBond, @maximumBond, @initialBonds, return) = {

        match "11112GofKy1v5mPWZjZEYBByvpZ4ahYJp6vFN1hgGCn7L543rFSpyA".hexToBytes() {

            posRevAddress => {

                new eitherCh,
                    revVaultCh,
                    listCh,
                    registryLookup(`rho:registry:lookup`) in {

                    registryLookup!(`rho:id:j6trahbxycumerwpr5qype7j43b7eqh8auebwsa9nn68if47gswh73`, *eitherCh)
                    | registryLookup!(`rho:id:1o93uitkrjfubh43jt19owanuezhntag5wh74c6ur5feuotpi73q8z`, *revVaultCh)
                    | for (@(_, Either) <- eitherCh; @(_, RevVault) <- revVaultCh; @(_, ListOps) <- listCh) {

                        new bondsCh,
                            this,
                            getParameters(`rho:deploy:params`),
                            revAddressOps(`rho:rev:address`),
                            paymentStore,
                            deposit in {

                            bondsCh!(initialBonds)

                            | contract this (@"getBonds", return) = {
                                for(@bonds <- bondsCh) {
                                    bondsCh!(bonds) | return!(bonds)
                                }
                            }

                            // TODO: Validate that the associated wallet comes from the same mint as the purse
                            // TODO: Can we assume at this point that [[@pk]] is a valid public key?
                            | contract this (@"bond", @bondAmount, @sigVerify, return) = {

                                new bondResultCh,
                                    isBonded,
                                    validateBondAmount,
                                    validateBondingRate,
                                    validatePublicKey,
                                    updateBonds,
                                    parametersCh in {

                                    @Either!(
                                        "compose",
                                        bondAmount,
                                        [*validateBondAmount,
                                        *validateBondingRate,
                                        *validatePublicKey,
                                        *deposit,
                                        *updateBonds],
                                        *return
                                    )

                                    | contract isBonded (@userPk, return) = {
                                        for(@bonds <- bondsCh) {
                                            bondsCh!(bonds) | return!(bonds.contains(userPk))
                                        }
                                    }

                                    | contract validateBondAmount (@bondAmount, return) = {
                                        if (bondAmount < minimumBond) {
                                            return!((false, "Bond less than minimum!"))
                                        } else if (bondAmount > maximumBond) {
                                            return!((false, "Bond greater than maximum!"))
                                        } else {
                                            return!((true, bondAmount))
                                        }
                                    }

                                    // TODO: figure out rate-limiting of bonding
                                    | contract validateBondingRate (@bondAmount, return) = {
                                        return!((true, bondAmount))
                                    }

                                    | contract validatePublicKey (@bondAmount, return) = {
                                        new isBondedCh, parametersCh in {
                                            getParameters!(*parametersCh)
                                            | for (_, _, @userPk, _ <- parametersCh) {
                                                isBonded!(userPk, *isBondedCh)
                                                | for (@isBondedResult <- isBondedCh) {
                                                    if (isBondedResult) {
                                                        return!((false, "Public key ${pk} already bonded." %% {"pk" : userPk}))
                                                    } else return!((true, bondAmount))
                                                }
                                            }
                                        }
                                    }

                                    | contract updateBonds (@bondAmount, return) = {
                                        new parametersCh in {
                                            getParameters!(*parametersCh)
                                            | for(@bonds <- bondsCh; _, _, @userPk, _ <- parametersCh) {
                                                bondsCh!(
                                                    bonds.set(
                                                        userPk,
                                                        [bondAmount, sigVerify, bonds.size() + 1]
                                                    )
                                                ) | return!((true, "Bond successful!"))
                                            }
                                        }
                                    }
                                }
                            }

                            //Assuming that user public key is valid, a vault should always be returned.
                            | contract deposit (@amount, return) = {
                                new parametersCh,
                                    vaultCh,
                                    revAddressCh in {
                                    getParameters!(*parametersCh)
                                    | for (_, _, @userPk, _ <- parametersCh) {
                                        revAddressOps!("fromPublicKey", userPk, *revAddressCh)
                                        | for (@revAddress <- revAddressCh) {
                                            @RevVault!("findOrCreate", revAddress, *vaultCh)
                                            | for (@(true, vault) <- vaultCh) {
                                                @vault!("transfer", posRevAddress, amount, *return)
                                            }
                                        }
                                    }
                                }
                            }

                            | paymentStore!([Nil, Nil, Nil, Nil])

                            //Make it easy to query the last payment so that validators
                            //can check how much phlo there is for the deploy.
                            | contract this(@"lastPayment", return) = {
                                for(@payment <- paymentStore) {
                                    paymentStore!(payment) | return!(payment)
                                }
                            }

                            | contract this (@"pay", @amount, return) = {
                                new parametersCh, depositRet in {
                                    deposit!(amount, *depositRet)
                                    | getParameters!(*parametersCh)
                                    | for (@depositResult <- depositRet; @codeHash, @phloRate, @userPk, @timestamp <- parametersCh; lastPayment <- paymentStore) {
                                        match depositResult {
                                            (true, Nil) => { paymentStore!([codeHash, userPk, timestamp, phloRate * amount]) | return!(phloRate *amount) }
                                            (false, err) => { paymentStore!([codeHash, userPk, timestamp, 0]) | return!(0) }
                                        }
                                    }
                                }
                            }

                            | return!(bundle+{*this})
                        }
                    }
                }
            }
        }
    } |
    rs!(
        "da19138c71db4010e791f40cbf73fb1e5dda989a8f3f5bca83f324b6529c5869".hexToBytes(),
        (9223372036854775807, bundle+{*MakePoS}),
        "ed32eef76c52261643566de4a9305d3a63385598c66d800ace0002141243ba212eae6171a7d2899f60957c3cb497fa5eca84106b02e708e084867fc902003e03".hexToBytes(),
        *uriOut
    )
}